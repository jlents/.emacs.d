(ns hello-compojure.database
  (:require [monger.core :as mg]
            [monger.collection :as mc]
            [clojure.core.cache :refer :all]
            [monger.cache :refer :all]
            [monger.ring.session-store :refer [session-store]]
            [hello-compojure.config :as config])
  (:import org.bson.types.ObjectId))

(defonce conn (mg/connect (mg/server-address config/host config/port)))

;;TODO determine final resting place for these db's and probably make them private
(def db (mg/get-db conn config/storage-db))
(def cache-db (mg/get-db conn config/cache-db))
(def session-db (mg/get-db conn config/session-db))

(session-store session-db "sessions")
(basic-monger-cache-factory cache-db "cache")

(defn generate-uuid []
  (str (java.util.UUID/randomUUID)))

(defn count-docs [coll options]
  "Will count the number of documents in the given collection"
  (mc/count db coll options))

(defn distinct-vals [coll key query]
  "Finds all the distinct values for the key in the collection matching the query"
  (mc/distinct db coll key query))

(defn any? [coll conditions]
  "Takes optional conditions and returns number in collection or number matching conditions"
  (mc/any? db coll conditions))

(defn get-map [coll & args]
  "Finds a single document in the collection that matches ref"
  (let [ref (first args)
        conditions (second args)
        conditions (if (nil? conditions) {} conditions)]
    (mc/find-one db coll ref conditions)))

(defn get-maps [coll & args]
  "Finds all of the document in the collection matching the reference"
  (let [ref (first args {})
        conditions (second args)
        conditions (if (nil? conditions) {} conditions)]
  (mc/find db coll ref conditions)))

(defn put-map [coll & args]
  "Inserts a single document into the collection.
   Does not allow insertion of an empty map: {}. "
  (let [document (first args)
        document (if (empty? document) nil document)]
  (mc/insert db coll document)))

(defn put-maps [coll & args]
  "Batch insert multiple documents into a collection"
  (let [docs (first args)
        docs (if (empty? doc) nil doc)
        concern (second args)
        concern (if (nil? doc) {} concern)]
  (mc/insert db coll docs concern)))


;(find-and-modify db coll conditions document {:keys [fields sort remove return-new upsert keywordize], :or {fields nil, sort nil, remove false, return-new false, upsert false, keywordize true}})

;; I don't know if you look at it this way, but chess is like a race to me.

;; When it comes down to it, it's all about who can get to checkmate the fastest.

;; Every move is a contingency plan reacting to your opponent who is trying their hardest to impede your progress and get to checkmate faster than you.

;; *steps down from soapbox and sits back down*
